<!DOCTYPE html>
<html lang="da">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Byg-selv Lydplanlægger</title>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700;900&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg:#000;
      --card:#111;
      --accent:#00ff88;
      --muted:rgba(255,255,255,0.75);
      --ls-green-1:#0B6623;
      --ls-green-2:#1E7A2E;
      --ls-green-3:#2FA84F;
      --ls-green-4:#5FCF73;
      --ls-green-5:#7AD37A;
      --ls-green-6:#A4E1A6;
      --ls-green-7:#CDECCB;
    }
    html,body{
      margin:0;height:100%;
      font-family:Montserrat,system-ui,Arial,sans-serif;
      background:var(--bg);color:#fff;
      text-transform:uppercase;
    }
    body{display:flex;flex-direction:column;}
    .ls-topbar{display:flex;align-items:center;padding:8px 12px;background:var(--card);color:#fff;gap:8px;font-size:14px;}
    .ls-topbar input,.ls-topbar select{margin-right:8px;background:#222;color:#fff;border:1px solid #333;padding:6px;border-radius:4px;}
    .ls-topbar button{margin-right:8px;padding:6px 10px;border:none;border-radius:4px;background:var(--accent);color:#000;font-weight:700;cursor:pointer;}
    .ls-main{flex:1;display:flex;}
    .ls-left{width:180px;background:var(--card);padding:8px;font-size:14px;}
    .ls-left ul{list-style:none;padding:0;margin:8px 0 0;}
    .ls-left li{margin-bottom:4px;cursor:pointer;padding:4px;border-radius:4px;}
    .ls-left li.active{background:var(--accent);color:#000;}
    .ls-dropdown{position:relative;}
    .ls-dropdown-menu{display:none;position:absolute;left:0;top:100%;background:#222;padding:0;margin:4px 0 0;list-style:none;z-index:10;border-radius:4px;}
    .ls-dropdown-menu li{margin:0;padding:4px 8px;}
    .ls-dropdown.open .ls-dropdown-menu{display:block;}
    .ls-canvas-container{flex:1;position:relative;background:var(--bg);overflow:hidden;}
    #ls-canvas{width:100%;height:100%;background-size:25px 25px;background-image:linear-gradient(0deg,rgba(255,255,255,0.05) 1px,transparent 1px),linear-gradient(90deg,rgba(255,255,255,0.05) 1px,transparent 1px);}
    .ls-right{width:260px;background:var(--card);display:flex;flex-direction:column;}
    .ls-products,.ls-cart{padding:8px;flex:1;overflow:auto;font-size:14px;}
    .ls-tabs{display:flex;gap:4px;margin-bottom:8px;}
    .ls-tabs button{flex:1;padding:6px;border:none;background:#222;color:#fff;cursor:pointer;border-radius:4px;}
    .ls-tabs button.active{background:var(--accent);color:#000;}
    .ls-product-list{list-style:none;padding:0;margin:0;}
    .ls-product-list li{margin-bottom:4px;padding:4px;background:#222;color:#fff;cursor:pointer;border-radius:4px;}
    .ls-product-list li:hover{background:#333;}
    .ls-cart h3,.ls-products h3{margin-top:0;}
    .ls-legend{list-style:none;margin:8px 0 0;padding:0;display:grid;grid-template-columns:repeat(2,1fr);gap:4px;font-size:12px;}
    .ls-legend span{display:inline-block;width:20px;height:12px;margin-right:4px;vertical-align:middle;}
    .ls-cta{padding:8px;display:flex;flex-direction:column;gap:8px;}
    .ls-cta button{padding:10px;background:var(--accent);color:#000;border:none;border-radius:4px;cursor:pointer;font-weight:700;}
    .ls-onboarding{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background:#111;color:#fff;padding:12px 28px 12px 12px;border:1px solid var(--accent);font-size:14px;}
    .ls-onboarding-close{position:absolute;top:4px;right:4px;background:none;border:none;color:#fff;font-size:12px;cursor:pointer;}
  </style>
</head>
<body>
  <div class="ls-topbar">
    <select>
      <option>Indendørs</option>
      <option>Udendørs</option>
    </select>
    <input type="number" placeholder="Gæster" />
    <input id="dimension-input" type="text" placeholder="Længde × Bredde (m)" value="20×20" />
    <button>Undo</button>
    <button>Redo</button>
    <label><input id="heatmap-toggle" type="checkbox" checked /> Heatmap</label>
  </div>
  <div class="ls-main">
      <aside class="ls-left">
        <h3>Tegneværktøjer</h3>
        <div class="ls-dropdown" id="room-tool">
          <button id="room-tool-btn">RUMTEGNER ▾</button>
          <ul class="ls-dropdown-menu" id="room-tool-menu">
            <li data-tool="rect">REKTANGEL</li>
            <li data-tool="poly">FRIHÅND</li>
          </ul>
        </div>
        <ul>
          <li data-tool="measure">Målebånd</li>
        </ul>
      </aside>
    <div class="ls-canvas-container">
      <canvas id="ls-canvas"></canvas>
      <div class="ls-onboarding"><button class="ls-onboarding-close" aria-label="Luk onboarding">×</button>1. Tegn området → 2. Placer højttalere → 3. Tjek dækningen</div>
    </div>
    <aside class="ls-right">
      <div class="ls-products">
        <h3>Produkter</h3>
        <div class="ls-tabs">
          <button>Højttalere</button>
          <button>Subwoofere</button>
        </div>
        <ul class="ls-product-list">
          <li>Yamaha DXR12</li>
          <li>Yamaha DXS12 MKII</li>
          <li>dB Technologies B-Hype 12</li>
        </ul>
      </div>
      <div class="ls-cart">
        <h3>Kurv</h3>
        <p>Ingen produkter</p>
        <h4>Total: 0 DKK</h4>
        <ul class="ls-legend">
          <li><span style="background:#0B6623"></span> ≤84 dB</li>
          <li><span style="background:#1E7A2E"></span> 86 dB</li>
          <li><span style="background:#2FA84F"></span> 88 dB</li>
          <li><span style="background:#5FCF73"></span> 91 dB</li>
          <li><span style="background:#7AD37A"></span> 94 dB</li>
          <li><span style="background:#A4E1A6"></span> 97 dB</li>
          <li><span style="background:#CDECCB"></span> ≥100 dB</li>
        </ul>
      </div>
      <div class="ls-cta">
        <button>Gem projekt</button>
        <button>Send forespørgsel</button>
      </div>
    </aside>
  </div>
  <script type="module">
    import {PRODUCTS_SEED} from './PRODUCTS_SEED.js';
    import {calcCoverageGrid} from './utils/coverageGrid.js';

    const CELL_PX = 25; // 1m grid cell
    const area = {w:20, h:20};
    const canvas = document.getElementById('ls-canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = area.w * CELL_PX;
    canvas.height = area.h * CELL_PX;
    canvas.style.cursor = 'default';

    const view = {x:0, y:0, scale:1};
    canvas.style.transformOrigin = '0 0';
    function updateTransform(){
      canvas.style.transform = `translate(${view.x}px, ${view.y}px) scale(${view.scale})`;
    }
    updateTransform();

    function toWorld(e){
      const rect = canvas.getBoundingClientRect();
      const sx = e.clientX - rect.left;
      const sy = e.clientY - rect.top;
      return {
        x: (sx - view.x) / view.scale / CELL_PX,
        y: (sy - view.y) / view.scale / CELL_PX
      };
    }

    const onboarding = document.querySelector('.ls-onboarding');
    const onboardingClose = document.querySelector('.ls-onboarding-close');
    onboardingClose.addEventListener('click', () => onboarding.remove());

const speakers = [];
const shapes = [];
let tool = null;
let drawingRect = null;
let currentPolygon = null;
let cursorPos = null;
let showHeatmap = true;
const measurements = [];
let currentMeasurement = null;
let hoverShapeIdx = null;
let dragShape = null;

    const heatmapToggle = document.getElementById('heatmap-toggle');
    const roomTool = document.getElementById('room-tool');
    const roomToolBtn = document.getElementById('room-tool-btn');
    const roomToolMenu = document.getElementById('room-tool-menu');
    heatmapToggle.addEventListener('change', () => {
      showHeatmap = heatmapToggle.checked;
      render();
    });

    const dimensionInput = document.getElementById('dimension-input');
    dimensionInput.addEventListener('change', () => {
      const match = dimensionInput.value.match(/\s*(\d+(?:\.\d+)?)\s*[x×]\s*(\d+(?:\.\d+)?)/i);
      if(match){
        area.w = parseFloat(match[1]);
        area.h = parseFloat(match[2]);
        canvas.width = area.w * CELL_PX;
        canvas.height = area.h * CELL_PX;
        updateTransform();
        render();
      }
    });

      function hexToRgba(hex, alpha){
        const int = parseInt(hex.slice(1),16);
        const r=(int>>16)&255, g=(int>>8)&255, b=int&255;
        return `rgba(${r},${g},${b},${alpha})`;
      }

      const HANDLE_SIZE = 0.3; // meters

      function pointInPoly(pt, pts){
        let inside = false;
        for(let i=0,j=pts.length-1;i<pts.length;j=i++){
          const xi=pts[i].x, yi=pts[i].y;
          const xj=pts[j].x, yj=pts[j].y;
          const intersect = ((yi>pt.y)!=(yj>pt.y)) && (pt.x < (xj - xi)*(pt.y - yi)/(yj - yi) + xi);
          if(intersect) inside = !inside;
        }
        return inside;
      }

      function getRectHandle(rect,x,y){
        const right = rect.x + rect.w;
        const bottom = rect.y + rect.h;
        const cx = rect.x + rect.w/2;
        const cy = rect.y + rect.h/2;
        if(Math.abs(x-rect.x)<HANDLE_SIZE && Math.abs(y-rect.y)<HANDLE_SIZE) return 'nw';
        if(Math.abs(x-right)<HANDLE_SIZE && Math.abs(y-rect.y)<HANDLE_SIZE) return 'ne';
        if(Math.abs(x-rect.x)<HANDLE_SIZE && Math.abs(y-bottom)<HANDLE_SIZE) return 'sw';
        if(Math.abs(x-right)<HANDLE_SIZE && Math.abs(y-bottom)<HANDLE_SIZE) return 'se';
        if(Math.abs(y-rect.y)<HANDLE_SIZE && Math.abs(x-cx)<HANDLE_SIZE) return 'n';
        if(Math.abs(y-bottom)<HANDLE_SIZE && Math.abs(x-cx)<HANDLE_SIZE) return 's';
        if(Math.abs(x-rect.x)<HANDLE_SIZE && Math.abs(y-cy)<HANDLE_SIZE) return 'w';
        if(Math.abs(x-right)<HANDLE_SIZE && Math.abs(y-cy)<HANDLE_SIZE) return 'e';
        if(x>rect.x && x<right && y>rect.y && y<bottom) return 'move';
        return null;
      }

      function getPolyHandle(poly,x,y){
        for(let i=0;i<poly.points.length;i++){
          const p = poly.points[i];
          if(Math.hypot(p.x-x,p.y-y) < HANDLE_SIZE) return {mode:'vertex',idx:i};
        }
        if(pointInPoly({x,y}, poly.points)) return {mode:'move'};
        return null;
      }

      function drawRectHandles(rect){
        const handles = [
          {x:rect.x,y:rect.y},
          {x:rect.x+rect.w,y:rect.y},
          {x:rect.x,y:rect.y+rect.h},
          {x:rect.x+rect.w,y:rect.y+rect.h},
          {x:rect.x+rect.w/2,y:rect.y},
          {x:rect.x+rect.w/2,y:rect.y+rect.h},
          {x:rect.x,y:rect.y+rect.h/2},
          {x:rect.x+rect.w,y:rect.y+rect.h/2},
          {x:rect.x+rect.w/2,y:rect.y+rect.h/2}
        ];
        ctx.save();
        ctx.fillStyle = '#fff';
        ctx.strokeStyle = '#000';
        handles.forEach(h=>{
          ctx.fillRect(h.x*CELL_PX-3, h.y*CELL_PX-3, 6,6);
          ctx.strokeRect(h.x*CELL_PX-3, h.y*CELL_PX-3,6,6);
        });
        ctx.restore();
      }

      function drawPolyHandles(points){
        ctx.save();
        ctx.fillStyle = '#fff';
        ctx.strokeStyle = '#000';
        points.forEach(p=>{
          ctx.beginPath();
          ctx.arc(p.x*CELL_PX, p.y*CELL_PX, 3, 0, Math.PI*2);
          ctx.fill();
          ctx.stroke();
        });
        const cx = points.reduce((s,p)=>s+p.x,0)/points.length;
        const cy = points.reduce((s,p)=>s+p.y,0)/points.length;
        ctx.fillRect(cx*CELL_PX-3, cy*CELL_PX-3,6,6);
        ctx.strokeRect(cx*CELL_PX-3, cy*CELL_PX-3,6,6);
        ctx.restore();
      }

      function drawMeasurement(m){
        ctx.save();
        ctx.strokeStyle = '#f00';
        ctx.fillStyle = '#f00';
        ctx.beginPath();
        ctx.moveTo(m.start.x*CELL_PX, m.start.y*CELL_PX);
        ctx.lineTo(m.end.x*CELL_PX, m.end.y*CELL_PX);
        ctx.stroke();
        const dist = Math.hypot(m.end.x - m.start.x, m.end.y - m.start.y);
        const midX = (m.start.x + m.end.x)/2 * CELL_PX;
        const midY = (m.start.y + m.end.y)/2 * CELL_PX;
        ctx.fillText(dist.toFixed(2) + 'm', midX + 5, midY - 5);
        ctx.restore();
      }

    function drawRect(rect, preview=false){
      ctx.save();
      ctx.strokeStyle = '#000';
      ctx.fillStyle = preview ? 'rgba(0,0,255,0.1)' : 'rgba(0,0,0,0.2)';
      ctx.beginPath();
      ctx.rect(rect.x*CELL_PX, rect.y*CELL_PX, rect.w*CELL_PX, rect.h*CELL_PX);
      ctx.fill();
      ctx.stroke();
      ctx.restore();
    }

    function drawPoly(points, preview=false){
      if(points.length < 2) return;
      ctx.save();
      ctx.strokeStyle = '#000';
      ctx.fillStyle = preview ? 'rgba(0,0,255,0.1)' : 'rgba(0,0,0,0.2)';
      ctx.beginPath();
      ctx.moveTo(points[0].x*CELL_PX, points[0].y*CELL_PX);
      for(let i=1;i<points.length;i++){
        ctx.lineTo(points[i].x*CELL_PX, points[i].y*CELL_PX);
      }
      if(!preview && points.length>2){
        ctx.closePath();
        ctx.fill();
      }
      ctx.stroke();
      ctx.restore();
    }

    function render(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      if(showHeatmap){
        const grid = calcCoverageGrid({widthM:area.w,heightM:area.h,cellSizeM:1,speakers});
        grid.data.forEach((row,y)=>{
          row.forEach((cell,x)=>{
            if(cell.color.alpha>0){
              ctx.fillStyle = hexToRgba(cell.color.hex, cell.color.alpha);
              ctx.fillRect(x*CELL_PX, y*CELL_PX, CELL_PX, CELL_PX);
            }
          });
        });
      }
        // draw shapes
        shapes.forEach((shape,idx)=>{
          if(shape.type==='rect') drawRect(shape);
          if(shape.type==='poly') drawPoly(shape.points);
        });
        if(hoverShapeIdx!==null){
          const hs = shapes[hoverShapeIdx];
          if(hs.type==='rect') drawRectHandles(hs);
          if(hs.type==='poly') drawPolyHandles(hs.points);
        }
        measurements.forEach(m=>drawMeasurement(m));
        if(currentMeasurement) drawMeasurement(currentMeasurement);
      // draw previews
      if(drawingRect){
        const rect = {
          x: Math.min(drawingRect.xStart, drawingRect.xEnd),
          y: Math.min(drawingRect.yStart, drawingRect.yEnd),
          w: Math.abs(drawingRect.xEnd - drawingRect.xStart),
          h: Math.abs(drawingRect.yEnd - drawingRect.yStart)
        };
        drawRect(rect, true);
      }
      if(currentPolygon){
        const pts = cursorPos ? [...currentPolygon, cursorPos] : currentPolygon;
        drawPoly(pts, true);
      }
      // draw speakers
      speakers.forEach(sp=>{
        ctx.save();
        ctx.translate(sp.x*CELL_PX, sp.y*CELL_PX);
        ctx.rotate(sp.rotDeg*Math.PI/180);
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.moveTo(0,0);
        ctx.lineTo(-5,10);
        ctx.lineTo(5,10);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      });
    }

    // select drawing tool
    roomToolBtn.addEventListener('click', ()=>{
      roomTool.classList.toggle('open');
    });

    document.querySelectorAll('.ls-left li[data-tool]').forEach(li=>{
      li.addEventListener('click', ()=>{
        tool = li.dataset.tool;
        document.querySelectorAll('.ls-left li').forEach(el=>el.classList.toggle('active', el===li));
        roomTool.classList.remove('open');
      });
    });

    // Add speaker by clicking product
    document.querySelectorAll('.ls-product-list li').forEach((li,idx)=>{
      li.addEventListener('click', ()=>{
        const prod = PRODUCTS_SEED[idx];
        speakers.push({x:area.w/2,y:area.h/2,rotDeg:0,productId:prod.id});
        render();
      });
    });

    // canvas interactions
    let dragIdx = null;
    let isPanning = false;
    let panStart = {x:0,y:0};

    canvas.addEventListener('wheel', e=>{
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const sx = e.clientX - rect.left;
      const sy = e.clientY - rect.top;
      const wx = (sx - view.x) / view.scale;
      const wy = (sy - view.y) / view.scale;
      const factor = e.deltaY > 0 ? 0.9 : 1.1;
      view.scale *= factor;
      view.x = sx - wx * view.scale;
      view.y = sy - wy * view.scale;
      updateTransform();
    }, {passive:false});

    canvas.addEventListener('mousedown', e=>{
      if(e.button===1){
        isPanning = true;
        panStart.x = e.clientX - view.x;
        panStart.y = e.clientY - view.y;
        canvas.style.cursor = 'grabbing';
        return;
      }
      const {x,y} = toWorld(e);
      if(tool === 'measure'){
        currentMeasurement = {start:{x,y}, end:{x,y}};
        return;
      }

      const spIdx = speakers.findIndex(sp=>Math.hypot(sp.x-x, sp.y-y) < 0.5);
      if(spIdx !== -1){
        dragIdx = spIdx;
        canvas.style.cursor = 'grabbing';
        return;
      }

      for(let i=shapes.length-1;i>=0;i--){
        const sh = shapes[i];
        let hit = null;
        if(sh.type==='rect'){
          const mode = getRectHandle(sh,x,y);
          if(mode) hit = {idx:i, mode};
        }else if(sh.type==='poly'){
          const h = getPolyHandle(sh,x,y);
          if(h) hit = {idx:i, ...h};
        }
        if(hit){
          dragShape = hit;
          hoverShapeIdx = i;
          if(hit.mode==='move' && sh.type==='rect'){
            dragShape.offsetX = x - sh.x;
            dragShape.offsetY = y - sh.y;
          }
          if(hit.mode==='move' && sh.type==='poly'){
            dragShape.startX = x;
            dragShape.startY = y;
            dragShape.origPoints = sh.points.map(p=>({...p}));
          }
          render();
          return;
        }
      }
      if(tool === 'rect'){
        drawingRect = {xStart:x, yStart:y, xEnd:x, yEnd:y};
      }else if(tool === 'poly'){
        if(!currentPolygon){
          currentPolygon = [{x,y}];
        }else{
          currentPolygon.push({x,y});
        }
      }
    });

    canvas.addEventListener('mousemove', e=>{
      if(isPanning){
        view.x = e.clientX - panStart.x;
        view.y = e.clientY - panStart.y;
        updateTransform();
        return;
      }
      const {x,y} = toWorld(e);
      if(drawingRect){
        drawingRect.xEnd = x;
        drawingRect.yEnd = y;
        render();
      }else if(currentPolygon){
        cursorPos = {x,y};
        render();
      }else if(currentMeasurement){
        currentMeasurement.end = {x,y};
        render();
      }else if(dragShape){
        const sh = shapes[dragShape.idx];
        if(sh.type==='rect'){
          switch(dragShape.mode){
            case 'move':
              sh.x = x - dragShape.offsetX;
              sh.y = y - dragShape.offsetY;
              break;
            case 'nw':
              sh.w += sh.x - x;
              sh.h += sh.y - y;
              sh.x = x; sh.y = y; break;
            case 'ne':
              sh.w = x - sh.x;
              sh.h += sh.y - y;
              sh.y = y; break;
            case 'sw':
              sh.w += sh.x - x;
              sh.x = x;
              sh.h = y - sh.y; break;
            case 'se':
              sh.w = x - sh.x;
              sh.h = y - sh.y; break;
            case 'n':
              sh.h += sh.y - y;
              sh.y = y; break;
            case 's':
              sh.h = y - sh.y; break;
            case 'w':
              sh.w += sh.x - x;
              sh.x = x; break;
            case 'e':
              sh.w = x - sh.x; break;
          }
        }else if(sh.type==='poly'){
          if(dragShape.mode==='move'){
            const dx = x - dragShape.startX;
            const dy = y - dragShape.startY;
            sh.points = dragShape.origPoints.map(p=>({x:p.x+dx,y:p.y+dy}));
          }else if(dragShape.mode==='vertex'){
            sh.points[dragShape.idx] = {x,y};
          }
        }
        render();
      }else if(dragIdx!==null){
        speakers[dragIdx].x = x;
        speakers[dragIdx].y = y;
        canvas.style.cursor = 'grabbing';
        render();
      }else{
        let found = null;
        for(let i=shapes.length-1;i>=0;i--){
          const sh = shapes[i];
          let hit = null;
          if(sh.type==='rect') hit = getRectHandle(sh,x,y);
          else if(sh.type==='poly') hit = getPolyHandle(sh,x,y);
          if(hit){ found = i; break; }
        }
        if(found!==hoverShapeIdx){
          hoverShapeIdx = found;
          render();
        }
        const overSp = speakers.findIndex(sp=>Math.hypot(sp.x-x, sp.y-y) < 0.5);
        canvas.style.cursor = overSp !== -1 ? 'move' : 'default';
      }
    });

    canvas.addEventListener('mouseup', ()=>{
      if(isPanning){
        isPanning = false;
        canvas.style.cursor = 'default';
        return;
      }
      if(drawingRect){
        const rect = {
          x: Math.min(drawingRect.xStart, drawingRect.xEnd),
          y: Math.min(drawingRect.yStart, drawingRect.yEnd),
          w: Math.abs(drawingRect.xEnd - drawingRect.xStart),
          h: Math.abs(drawingRect.yEnd - drawingRect.yStart)
        };
        shapes.push({type:'rect', ...rect});
        drawingRect = null;
        render();
      }
      if(currentMeasurement){
        measurements.push(currentMeasurement);
        currentMeasurement = null;
        render();
      }
      dragIdx = null;
      dragShape = null;
      canvas.style.cursor = 'default';
    });

    canvas.addEventListener('mouseleave', ()=>{
      if(isPanning){
        isPanning = false;
        canvas.style.cursor = 'default';
      }
      if(drawingRect){
        drawingRect = null;
        render();
      }
      if(currentMeasurement){
        currentMeasurement = null;
        render();
      }
      dragIdx = null;
      dragShape = null;
      canvas.style.cursor = 'default';
    });

    canvas.addEventListener('dblclick', ()=>{
      if(tool === 'poly' && currentPolygon){
        if(currentPolygon.length >= 2){
          shapes.push({type:'poly', points: currentPolygon});
        }
        currentPolygon = null;
        cursorPos = null;
        render();
      }
    });

    canvas.addEventListener('contextmenu', e=>{
      e.preventDefault();
      const {x,y} = toWorld(e);
      if(tool === 'poly' && currentPolygon){
        if(currentPolygon.length >= 2){
          shapes.push({type:'poly', points: currentPolygon});
        }
        currentPolygon = null;
        cursorPos = null;
        render();
      }else{
        const sp = speakers.find(sp=>Math.hypot(sp.x-x, sp.y-y) < 0.5);
        if(sp){ sp.rotDeg = (sp.rotDeg + 15) % 360; render(); }
      }
    });

    render();
  </script>
</body>
</html>
